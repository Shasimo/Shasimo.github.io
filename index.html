<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/dreampulse/computer-modern-web-font@master/fonts.css">
    <style>
      body {
        font-family: "Computer Modern Serif", serif;
      }
    </style>
    <link href="css/screen.css" rel="stylesheet" />
    <link rel="icon" type="image/png" href="assets/images/shot.png">
    <title>Portalgons</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.10.0/p5.js"></script>
    <script src="src/constants.js"></script>
    <script src="src/point.js"></script>
    <script src="src/orientation.js"></script>
    <script src="src/isintriangle.js"></script>
    <script src="src/triangulation.js"></script>
    <script src="src/grid.js"></script>
    <script src="src/datastructures/minheap.js"></script>
    <script src="src/datastructures/bst.js"></script>
    <script src="src/portalgon/portalgonBuilder.js"></script>
    <script src="src/util.js"></script>
    <script src="src/portalgon/fragment.js"></script>
    <script src="src/portalgon/portal.js"></script>
    <script src="src/portalgon/portalgon.js"></script>
    <script src="src/portalgon/embed.js"></script>
    <script src="src/sweep/envelope.js"></script>
    <script src="src/sweep/signature.js"></script>
    <script src="src/sweep/distanceFunction.js"></script>
    <script src="src/sweep/testDataStruct.js"></script>
    <script src="src/sweep/mapentry.js"></script>
    <script src="src/sweep/events.js"></script>
    <!-- <script src="sketches-zones/animation.js"></script> -->
    <script src="src/sweep/shortestPathMap.js"></script>
    <script src="sketches-zones/input.js"></script>
    <script src="sketches-zones/zone2.js"></script>
    <script src="sketches-zones/zone3.js"></script>

    <script src="sketch.js"></script>
  </head>
  <body>
    <header>
      <h1>Shortest Paths in Portalgons</h1>
  </header>
    <section id="Abstract">
      <h2>Abstract</h2>
      <p>
        This page is the gathering of our effort put in the understanding of the "Shortest Paths in Portalgons" problem
        following the reading of the paper written by Löffler, Ophelders, Staals, I.Silveira <a href="#References">[1]</a>
        in the scope of the
        "Computational Geometry INFO-F420" ULB course given by Pr. Stefan Langerman.
        We present after a brief introduction the description of a shortest path map output by an algorithm taking a
        source point allowing fast queries on the pre-processed portalgon.
        We vividly encourage any interested reader to pursue the reading of this page with the reading the referenced
        paper <a href="#References">[1]</a> for further details.

    </section>


    <section id="Introduction">
      <h2>Introduction</h2>
          A portalgon is a pair \(\mathcal{P}=(\mathcal{F},\mathcal{E})\) where \(\mathcal{F}\) is a set of
      <i>fragments</i> and \(\mathcal{E}\) is a set of <i>portals</i>.<br>
          A fragment is a simple polygon.
          A portal is an unordered pair \(e=(e^-,e^+)\) of (distinct) directed edges of same length across any fragments.

      <figure>
        <img src="assets/images/exampleportalgon.png" width="300" height="356" alt="signatureExample"/>
        <figcaption>Figure 1. A simple example of a portalgon \(\mathcal{P}\).</figcaption>
      </figure>
      <h3>Motivation</h3>
      <p>
        Portalgons are a generalization of polyhedral surfaces.<br>
        Any polyhedron can be converted into an equivalent portalgon taking \(\mathcal{F}\) to be the set of (polygonal)
        faces of the polyhedron and placing a portal between two fragments wherever the two corresponding faces in the
        original polyhedron met.

      <figure>
        <img src="assets/images/cubeWithPortals.png" alt="Portalgon representing a cube" />
        <figcaption>Figure 2. A portalgon equivalent to a cube and a shortest path on its surface.</figcaption>
      </figure>
        The shortest path problem on the surface of a polyhedron thus reduces to a shortest path problem in a portalgon.
        Since multiple routes might lead to our destination, this problem remains tedious.
        However, the algorithm presented in "The Discrete Geodesic Problem"<a href="#References">[2]</a> remains
      a viable option in the case the portalgon is equivalent to a polyhedron.
      For more general portalgons, the number of portal crossings are not necessarily bounded, as we will see later.

      <p>
          Pushing the idea further, portalgons allow us to represent any shape we would be able to build by gluing and folding
        polygons made out of paper (note that this enables us to build more than just polyhedra).
        For instance, this means that we are able to construct a portalgon that is equivalent to a Möbius strip or the
          curved surface of a cylinder.

      <figure>
        <img src="assets/images/möbiusStrip.png" alt="Portalgon representing a Möbius strip"/>
      <figcaption>Figure 3. A portalgon equivalent to a Möbius strip
        (<a href="https://www.geogebra.org/m/NPmZwBc6">https://www.geogebra.org/m/NPmZwBc6</a>).</figcaption>
    </figure>

      <figure>
          <img src="assets/images/cylinder.png" alt="Portalgon representing a cylinder"/>
          <figcaption>Figure 4. A portalgon equivalent to the curved surface of a cylinder.</figcaption>
        </figure>

        When gluing the different fragments of a portalgon \(\mathcal{P}\) together, we obtain a surface \(\Sigma\).
        It turns out that \(\Sigma\) may not be embeddable in \(\mathbb{R}^2\) or \(\mathbb{R}^3\) without
      self-intersections (or, as we have seen, with flat faces).
      We say that \(\mathcal{P}\) is a <i>representation</i> of \(\Sigma\).
      A surface can have multiple representations.

      <p>
        Crucially, this last fact enables us to compute shortest paths on some curved surfaces and self-intersecting
        surfaces.

    <section id="Signatures">
      <h3>Paths and Signatures</h3>
      We define a path \(\pi:[0,1]\rightarrow \Sigma\) to be a function representing the path from a source point
      \(s\in\Sigma\) to a destination point \(d\in\Sigma\) such that \(\pi(0)=s\) and \(\pi(1)=d\).
      Note that the definition of a path is independent of the representation of the surface
      \(\Sigma\) the path is located in (i.e. a portalgon).
      For clarity, we will see paths as a collection of disconnected segments of lines from \(s\) to \(d\) in the input
      portalgon.
      In a portalgon \(\mathcal{P}\), a path is split into a set of maximal subpaths \(\pi_1,\ldots,\pi_k\) such that
      every \(\pi_i\) is fully contained into a single fragment of \(\mathcal{P}\).
      The length of a path \(\pi\) is defined to be the sum of the length of every \(\pi_i\).

      <p>
        This formal definition is not practical to work with programmatically.
        To solve this issue, we note that a path \(\pi\) may be fully described as the sequence of vertices and portals
        \(s=v_1,~e_1,\ldots,~e_k,~v_{k+1}=t\) it passes through.
        Observe that in the context of shortest paths, the vertices \(v_i\neq s,t\) have to be vertices of the fragments.

      <p>
      We define the <i>signature</i> of a path, denoted \(\sigma(\pi)\) to be this sequence (without the destination).

      <figure>
        <img src="assets/images/exampleSignature.png" alt="signatureExample"/>
        <figcaption>Figure 5. An example of a path \(\pi\) from \(s\) to \(d\) with signature
          \(\sigma(\pi)=v,e_1,e_2,e_3\).</figcaption>
      </figure>
    </section>

    <section id="Happiness">
      <h3>Happiness</h3>
      A natural question that arises when studying portalgons is to analyze the computational complexity of finding the shortest paths inside these structures.
      We define the <i>complexity</i> of a path \(\pi\) (in a portalgon \(\mathcal{P}\)) to be the length of its signature
      \(\sigma(\pi)\).
      <p>

      <figure id="housePortalgon">
      <img src="assets/images/unhappy.png" alt="not Happy House" />
        <figcaption>Figure 6. An example of a shortest path that goes 3 times through the same fragment before reaching its
          destination.</figcaption>
      </figure>

      The example above showcases how, with a single shortests path, we might have to cross a portal multiple times before
        being able to reach the destination.
      In particular, since we can make the parallelogram arbitrarily long, it shows that, in general, the
      number of times that a shortest path goes through a fragment is unbounded.
        We can imagine pathological cases where we tend to cross the same portal an unbounded number of times.

        <p>
        This leads us to the definition of the <i>happiness</i> \(\mathcal{H}(F)\) of a fragment \(F\in\mathcal{F}\).
      \(\mathcal{H}(F)\) is defined to be the maximal number of times that a shortest path between any pair of points
          \(p,q\in\Sigma\) crosses \(F\) (maximized over the choice of \(p\) and \(q\)).

        <p>
      We define the <i>happiness</i> \(\mathcal{H}(\mathcal{P})\) of a portalgon \(\mathcal{P}\) to be the highest
      happiness over all fragments of \(\mathcal{P}\) (\(\max_{F\in\mathcal{F}}\mathcal{H}(F)\)).
      A portalgon is \(h\)-happy when its happiness is a most \(h\).
      We say that a portalgon is <i>happy</i> if it is \(\mathcal{O}(1)\)-<i>happy</i>.
      Note that in these definitions, the happiness depends on a <i>portalgon</i> and not on a surface \(\Sigma\).
      Indeed, as we will see, different representations of the same surface can have different
      happiness.

      <p>
      Let \(\mathcal{P}\) be a \(h\)-happy portalgon with \(n\) vertices and \(m\) portals (\(2m\) portal edges).
      At most, the complexity of a shortest path is \( \mathcal{O}(n + hm) \) (indeed, a shortest path may go through
      each vertex only once and go through each portal exactly \(h\) times).

      <p>
      The notion of happiness has repercussions on the possible algorithms that can solve the shortest path problem:
      if \(h\) is unbounded, the total number of signatures is too and simple bruteforce algorithm might not work.

      <figure id="housePortalgonTransformed">
        <img src="assets/images/happy.png" alt="HappyHouse" />
        <figcaption>Figure 7. A portalgon equivalent to the one of figure <a href="#housePortalgon">6</a> but
          with constant happiness.</figcaption>
      </figure>
      A result of <a href="#References">[1]</a> is that for any portalgon \(\mathcal{P}\), there exists a portalgon
      \(\mathcal{P}'\) equivalent to \(\mathcal{P}\) but with  \(\mathcal{O}(1)\)-happiness.
      <p>
        Because the complexity of a path is \( \mathcal{O}(n + hm) \), a shortest path in a happy portalgon
        would only have paths of length  \( \mathcal{O}(n + m) = \mathcal{O}(n)\), which is very useful to compute
        shortest paths quickly.

    </section>


    <section id="Embedding of a signature">
      <h3>Embedding of a signature</h3>
      Let \(\mathcal{P}=(\mathcal{F},\mathcal{E})\) be an input portalgon.
      To embed a signature \(\sigma(\pi)\) in \(\mathbb{R}^2\), take the ordered sequence of portals
      \(E=(e_1,e_2,\ldots e_k)\subseteq \mathcal{E}\) it contains.
      Let \(F_0\) be the fragment that contains the source point.
      For each portal \(e_i=(e_i^-, e_i^+)\in E\), assume that \(e_i^-\) is an edge of \(F_{i-1}\) and \(e_i^+\)
      is an edge of \(F_{i}\) with \(\{F_0,\ldots,F_k\}\subseteq \mathcal{F}\).
      For each edge \(e_i\in E\), we will stitch \(F_{i-1}\) with \(F_{i}\) by gluing \(e_i^-\) with \(e_i^+\) according to their direction.

      <p>
        This way, to embed \(F_i\), rotate it and translate it in order to align the starts of \(e_i^-\) and \(e_i^+\).
        In some cases, \(F_{i-1}\) and \(F_i\) might overlap after such transformations.
        If that it the case, take the reflection of \(F_i\) with \(e_i\) as the axis of symmetry.
        Note that rotation, translation and refection are all isometries.

      <figure>
        <img src="assets/images/embedding.png" alt="Portalgon embedding"/>
        <figcaption>Figure 8. The embedding of a the signature \(\sigma(\pi)=s,e_1,e_2,e_3,e_4\) of a path
          \(\pi\) from \(s\) to \(d\).</figcaption>
      </figure>

    </section>
    </section>

    <section id="Interactive Example">
      <h2>Interactive example</h2>
      <p>
        Before going into the specifics of how the shortest path algorithm is implemented, we invite the reader to
        design a portalgon using our tool here under.
      This enables the reader to then find a shortest path between two arbitrarily chosen point in their portalgon.

      <section id="buildyourownZone">
      <h3>Build your own portalgon</h3>
        <i>Usage of the tool:</i>
      <ol>
        <li>Click on the grid and create a fragment (must be a simple polygon).</li>
        <li>When the current fragment is done, press <i>Next Fragment</i> and repeat until you have finished creating
          your fragments (two fragments cannot overlap).</li>
        <li>When every fragment is created, press <i>Next Fragment</i> one last time and press <i>Pick Portals</i>.</li>
        <li>To place a portal, click on the dominant vertex of the edge you want to select to be an end of the portal and
          then select another edge <i>(remember that the two edges of a portal must be of the same length!)</i>.
          Clicking again of the dominant vertex of one of the ends of a portal toggles its direction.</li>
        <li>When the current portal is done, click <i>Next Portal</i> and repeat until you are done placing portals.</li>
        <li>When everything is done, press <i>Next Portal</i> one last time and click <i>Finish</i>. You are done!</li>
      </ol>

      <div id="zone-one"> </div>
    </section>

      <section id="TriangulationZone">
        <h3>Triangulation of your portalgon</h3>
        The following zone shows a triangulated version of your portalgon (if you did not forget to validate it!).
        You are now able to place two points: a source point (blue) and a destination point (red).
        Note that you can change the position of the destination point at any point by simply clicking on the new
        desired position.
        <div id="zone-two" ></div>
      </section>
      <section id="shortestPathZone">
        <h3>Shortest Path</h3>
        <div id="zone-three"> </div>
      </section>
    </section>

    <section id="SPMtoEdges">
      <h2>Shortest Path Map to the portals</h2>

      The goal of the algorithm that we are building is to compute the shortest path map from a source point
      \(s\in\Sigma\) (denoted \(SPM:=SPM(s)\)).
      A \(SPM\) is a subdivision of \(\Sigma\) into maximally connected regions such that in all regions
      \(R\in\textit{SPM}(s)\), the signature of the shortest path from \(s\) to \(p\) is the same for all \(p\in R\).

      <p>
      To compute the whole \(SPM\), we must start by computing \(SPM_e\) for every portal \(e\in\mathcal{E}\).
      We define \(SPM_e\) to be a subdivision of \(e\) into maximally connected segments \(S\subseteq e\) where the
      signature of the shortest path from \(s\) to \(p\) is the same for all \(p\in S\).
      This way, \(SPM_e\) gives the shortest path from \(s\) to any point of \(e\).

      <section id="Distance">
        <h3>Distance</h3>
        Let us say that we would like to find \(SPM_e\) for some portal \(e\).
        Let \(\pi\) be a shortest path from \(s\) to some point where \(e\) is the last portal in \(\sigma(\pi)\).
        Let \(v\) be the last vertex in \(\sigma(\pi)\).
        We define \(I_{\sigma(\pi),e}\) to be the interval of points on \(e\) that can be reached in a straight line
      from \(v\) (i.e. the interval of points that are visible from \(v\)).

        <figure>
          <img src="assets/images/intervalExample.png" alt="intervalExample"/>
          <figcaption>Figure 9. Example of \(I_{\sigma(\pi), e_5}\) (the interval of points between \(L\) and \(W\))
            for a signature \(\sigma(\pi)=s,\ldots, v, e_1, e_2, e_3, e_4, e_5\).</figcaption>
        </figure>

        We can now define the length of a shortest path of signature \(\sigma(\pi)\) from a source \(s\) to some point
      \(q\in e\), given the distance from \(s\) to \(v\) (\(d(s,v)\)), as following:

        \[f_{\sigma(\pi)\mid e}:e\rightarrow \mathbb{R}\cup\{\infty\}:q\mapsto
        \begin{cases}
        d(s,v)+\left\|\overline{vq}\right\| & \text{if \(q\in I_{\sigma(\pi),e}\)}\\
        \infty                              & \text{otherwise}
        \end{cases}\]

      The two cases are justified by the fact that, clearly, if \(q\notin I_{\sigma(\pi),e}\), \(q\) is unreachable
      using the signature \(\sigma(\pi)\).

      <p>
      In the actual implementation of the algorithm, the distance functions \(f_{\sigma(\pi),e}\) are objects
        that have access to:
      <ol>
      <li>The signature \(\sigma(\pi)\) it is linked to.</li>
      <li>The position of \(v\) in the embedding of the signature.</li>
      <li>The position of both ends of \(e\) in the embedding of the signature.</li>
      <li>\(d(s,v)\)</li>
      <li>The interval \(I_{\sigma(\pi),e}\) it is defined on.</li>
    </ol>

      In particular, this means that finding the embedding of the signature \(\sigma(\pi)\) is necessary to compute
      \(f_{\sigma(\pi),e}\).
      Given this information, a distance function may be queried for any input \(q\in e\) in \(\mathcal{O}(1)\), which
      is enough to perform the operations described later on them.

      </section>

      <section id="Envelopes">
        <h3>Envelopes</h3>

        Clearly, \(f_{\sigma(\pi),e}\) is a symmetric function, increasing as the distance to its minimum increases.
        Except these facts, the exact shape of a distance function \(f_{\sigma(\pi),e}\) is of
        no importance.
        <p>
          Let \(e\) be some portal.
          Take every path \(\pi\) from \(s\) with a signature \(\sigma(\pi)\) that ends in \(e\).
          For all of these signatures, we can plot \(f_{\sigma(\pi),e}\).
          The very important fact to notice is that the lower <i>envelope</i> of this set of functions is the \(SPM_e\)!
        Indeed, the interval of \(e\) in which some signature \(\sigma\) gives a minimal distance function is an
        interval where the signature \(\sigma\) is optimal.

        <figure>
          <img src="assets/images/distancefunctionfused.png" alt="envelopeportalgonanddistances"/>
          <figcaption>Figure 10. A portalgon and a collection of paths from \(s\) to \(e\) (in red) with signature
            \(\sigma=s\) and a collection of paths (in blue) with a signature \(\sigma'=s,e_1\) alongside
            the plot of \(f_{\sigma,e}\) and \(f_{\sigma',e}\).</figcaption>
        </figure>

        This gives a direct bruteforce algorithm to compute the \(SPM\) restricted to the edges: given a portal \(e\),
        compute every possible signature that goes from \(s\) to \(e\) and compute the lower envelope of the
        distance functions \(f_{\sigma(\pi),e}\).
        To find the shortest path from \(s\) to a point \(q\in e\), find which distance function realizes the envelope
        at point \(q\) and retrieve its signature.

        <p>
        Note that, as shown in the previous figure, an envelope lives in the \(e\times \delta\) space, where \(\delta\)
        is the distance from the origin to some point on \(e\).

      </section>

      <section id="dsEnvelope">
        <h3>Data structure to maintain a lower envelope</h3>
        As stated in the precedent section, we would like to maintain a lower envelope of a set of distance functions
        \(F=\{f_{\sigma_1,e},f_{\sigma_2,e},\ldots,f_{\sigma_k,e}\}\) for every edge \(e\).
        The authors of <a href="#References">[1]</a> propose an efficient data structure to do so.
        First of all, note that any functions \(f\) and \(f'\) can only intersect twice because of their shape.
          <p>
          This data structure supports the following operations:
        <ul>
        <li>\(\texttt{Insert(}f\texttt{)}\): the insertion of a new function \(f_{\sigma_i,e}\).</li>
        <li>\(\texttt{NextLocalMinimum(}\delta\texttt{)}\): finding the smallest local minimum larger than \( \delta \).</li>
        <li>\(\texttt{NextVertex(}f,q\texttt{)}\): given a function \(f\) realizing the envelope at some point \(q\in e\), find the lowest intersection
          \((v,f'(v))\) of \(f\) with some other function \(f'\in \text{env}\) such that \(f'(v)>f(q)\).</li>
      </ul>
        We represent the envelope of our functions \(f\in F\), \(\text{env}_F\) with \(\mathcal{O}(\log m)\) of these lower
        envelope data structures.
        Every sub-envelope \(\text{env}_i\) contains
          a binary search tree of the intervals of the envelope ordered by their \(x\)-coordinates (these intervals
        can be seen obtained by collapsing the functions \(f_{\sigma_j,e}\in\text{env}_i\) on the \(x\)-axis) and a
          a list of local minima, ordered by their \(y\)-coordinates.
        Every envelope \(\text{env}_i\) stores the lower envelope of \(2^i\) functions from \(F\).

        <p>
        To handle the \(\texttt{NextLocalMinimum(}\delta\texttt{)}\) queries, we can binary search on the
          \(\mathcal{O}(\log m)\) sub-envelopes \(\text{env}_i\) and find the local minimum of \(\text{env}_i\) by
          binary searching its minima list.
        This lets us answer such queries in \(\mathcal{O}(\log^2 m)\) time.

          <p>
        To tackle \(\texttt{NextVertex(}f,q\texttt{)}\) queries, we consider every \(\text{env}_i\) one by one
        (remember that we have \(\mathcal{O}(\log m)\) of those).
        We do a binary search on the vertices of the intervals of \(\text{env}_i\) to find the function \(f'\) realizes
        \(\text{env}_i\) at point \(q\).
        Then, we walk to the right of the envelope, examining every new function \(g\) that we encounter until we have
        found an intersection between some function \(g\) and \(f\) (or not).
        We do the same on the left side and record the intersection point \(p\) with the lowest \(y\)-coordinate over
        all sub-envelopes.
        Clearly, answering the query in this way takes time
        \[\mathcal{O}\left(\sum_{i=0}^{\mathcal{O}(\log m)}\overbrace{\left(|env_i|+ \log |env_i|\right)}^{\text{walking + binary search}}\right)=
        \mathcal{O}\left(\sum_{i=0}^{\mathcal{O}(\log m)}|env_i|\right)=\mathcal{O}(\log^2 m)\]

        <p>
        Finally, to insert a function \(f\), create a new envelope \(\text{env}'_0\) containing only \(f\).
        If there exists another envelope \(\text{env}_0\), merge the two envelopes.
        Proceed recursively until every sub-envelope has a different size.
        To merge two envelope at a level \(i\) (of size \(2^i\)), one can merge the local minima list in linear time and
        compute the actual intervals of the envelope by walking simultaneously on \(\text{env}_i\) and \(\text{env}'_i\)
        in time \(\mathcal{O}(|\text{env}_i| + |\text{env}'_i| + |\text{env}'_{i+1}|)\).
        The authors then proceed to prove that the total number of intervals that are created during a sequence of \(m\)
        insertions is at most \(\mathcal{O}(\lambda_4(m)\log m)\) where \(\lambda_4(m)\) is the length of some
        Davenport-Schintzel sequence, the details of which are out of the scope of this interactive paper.
        Instead, we use the equivalence provided in <a href="#References">[3]</a> to get the following bound
        (\(\alpha(n)\) is the inverse Ackermann function).
        \[\mathcal{O}(\lambda_4(m)\log m)=\mathcal{O}(m2^{\alpha(m)}\log m)\]


      </section>

      <section id="Event">
        <h3>Events</h3>
        <p>
          Different events can be triggered when crossing an edge \(e\). These events are stored in a 
          priority queue for an edge \(e\) where the \(\delta\)' value the type of function associated with the events are saved.
          The events take the form of a minimum of a function, a vertex from an endpoint of the edge or an intersection between functions from 
          the lower envelope.
      </p>
      </section>

      <section id="Algorithm">
        <h3>Sweepline Algorithm</h3>
        We use a sweepline algorithm to progressively compute the shortest path map. The objective is to increase the height 
        of the sweepline \( \delta \) while maintaining the shortest path map below it. By doing so, we can identify the relevant 
        breakpoints that construct the shortest path \(\pi\).
        <p>
        Initially, the height of the sweepline is set to \( \delta = 0 \), and the set of signatures \(S_{k(e, 0)}\) for all edges \(e\) that do not 
        contain the source \( s \) is empty. The only possible event at this stage is moving from the source \( s \) to a portal, 
        provided that \( s \) lies inside the triangle. At any event, new signatures of a path \(\pi\) may appear, and we generate functions based on 
        these signatures. Functions that lie below the sweepline and do not contribute to the lower envelope are removed. 
        Additionally, we check for new available events.
        </p>
        This process continues until no further events can be added to the priority queue. At this point, the algorithm terminates
        and we found the shortest path map from the source \( s \) to a destination located on the edge of the portalgon.

      </section>
    </section>


    <section id="Authors">
      <h2>Authors</h2>
      <ul>
        <li>Schleusner Shan</li>
          <ul>
            <li>website setup</li>
            <li>portalgons drawings</li>
            <li>theoretical writeup</li>
          </ul>
        <li>Vannimmen Mathieu</li>
          <ul>
            <li>portalgon builder</li>
            <li>embedding implementation</li>
            <li>theoretical writeup</li>
          </ul>
        <li>Testaert Sacha</li>
          <ul>
            <li>portalgons drawings</li>
            <li>theoretical writeup</li>
          </ul>
      </ul>
    </section>

    <section id="References">
      <h2>References</h2>
      <ul>
        <li>[1] M.Löffler, T.Ophelders, F.Staals, R.I.Silveira, "Shortest Paths in Portalgons", arXiv:2303.08937v1 [cs.CG] 15 Mar 2023</li>
        <li>[2] JOSEPH S. B. MITCHELL, DAVID M. MOUNT AND CHRISTOS H. PAPADIMITRIOU, "THE DISCRETE GEODESIC PROBLEM", Vol. 16, No. 4, Society for Industrial and Applied Mathematics, pp. 647-668, Aug. 1987</li>
        <li>[3] Sharir, M. (1988). Davenport-Schinzel Sequences and their Geometric Applications. In: Earnshaw, R.A. (eds) Theoretical Foundations of Computer Graphics and CAD. NATO ASI Series, vol 40. Springer, Berlin, Heidelberg. https://doi.org/10.1007/978-3-642-83539-1_9</li>
      </ul>

      <h3>Additional resources</h3>

      <ul>
        <li>[A] Wolfgang Muzler, "Shortest Paths in Polygons", Frei Universität Berlin, 22 april 2021</li>
        <li>Maarten Löffler et al., EuroCG, 2021 april 7-9, https://www.youtube.com/watch?v=l04dpczEGqU</li>
      </ul>
    </section>

  </body>
</html>